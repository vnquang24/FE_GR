/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useChcnContext, ChcnContext, queryKeyFn } from "./chcnContext";
import { deepMerge } from "./chcnUtils";
import type * as Fetcher from "./chcnFetcher";
import { chcnFetch } from "./chcnFetcher";
import type * as Schemas from "./chcnSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type AppControllerHealthError = Fetcher.ErrorWrapper<undefined>;

export type AppControllerHealthVariables = ChcnContext["fetcherOptions"];

export const fetchAppControllerHealth = (
  variables: AppControllerHealthVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<undefined, AppControllerHealthError, undefined, {}, {}, {}>({
    url: "/api/health",
    method: "get",
    ...variables,
    signal,
  });

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function appControllerHealthQuery(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/health",
      operationId: "appControllerHealth",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAppControllerHealth(variables, signal),
  };
}

export const useSuspenseAppControllerHealth = <TData = undefined,>(
  variables: AppControllerHealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerHealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    AppControllerHealthError,
    TData
  >({
    ...appControllerHealthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAppControllerHealth = <TData = undefined,>(
  variables: AppControllerHealthVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AppControllerHealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useQuery<undefined, AppControllerHealthError, TData>({
    ...appControllerHealthQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AuthControllerLoginError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLoginResponse = {
  accessToken?: string;
  refreshToken?: string;
};

export type AuthControllerLoginVariables = {
  body: Schemas.LoginDto;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerLogin = (
  variables: AuthControllerLoginVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    AuthControllerLoginResponse,
    AuthControllerLoginError,
    Schemas.LoginDto,
    {},
    {},
    {}
  >({ url: "/api/auth/login", method: "post", ...variables, signal });

export const useAuthControllerLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerLoginResponse,
      AuthControllerLoginError,
      AuthControllerLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    AuthControllerLoginResponse,
    AuthControllerLoginError,
    AuthControllerLoginVariables
  >({
    mutationFn: (variables: AuthControllerLoginVariables) =>
      fetchAuthControllerLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRegisterResponse = {
  accessToken?: string;
  refreshToken?: string;
};

export type AuthControllerRegisterVariables = {
  body: Schemas.RegisterDto;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerRegister = (
  variables: AuthControllerRegisterVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    AuthControllerRegisterResponse,
    AuthControllerRegisterError,
    Schemas.RegisterDto,
    {},
    {},
    {}
  >({ url: "/api/auth/register", method: "post", ...variables, signal });

export const useAuthControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRegisterResponse,
      AuthControllerRegisterError,
      AuthControllerRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    AuthControllerRegisterResponse,
    AuthControllerRegisterError,
    AuthControllerRegisterVariables
  >({
    mutationFn: (variables: AuthControllerRegisterVariables) =>
      fetchAuthControllerRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRefreshTokenError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRefreshTokenResponse = {
  accessToken?: string;
};

export type AuthControllerRefreshTokenVariables = {
  body: Schemas.RefreshTokenDto;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerRefreshToken = (
  variables: AuthControllerRefreshTokenVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    AuthControllerRefreshTokenResponse,
    AuthControllerRefreshTokenError,
    Schemas.RefreshTokenDto,
    {},
    {},
    {}
  >({ url: "/api/auth/refresh-token", method: "post", ...variables, signal });

export const useAuthControllerRefreshToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRefreshTokenResponse,
      AuthControllerRefreshTokenError,
      AuthControllerRefreshTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    AuthControllerRefreshTokenResponse,
    AuthControllerRefreshTokenError,
    AuthControllerRefreshTokenVariables
  >({
    mutationFn: (variables: AuthControllerRefreshTokenVariables) =>
      fetchAuthControllerRefreshToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerLogoutError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerLogoutVariables = {
  body: Schemas.RefreshTokenDto;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerLogout = (
  variables: AuthControllerLogoutVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    undefined,
    AuthControllerLogoutError,
    Schemas.RefreshTokenDto,
    {},
    {},
    {}
  >({ url: "/api/auth/logout", method: "post", ...variables, signal });

export const useAuthControllerLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerLogoutError,
      AuthControllerLogoutVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerLogoutError,
    AuthControllerLogoutVariables
  >({
    mutationFn: (variables: AuthControllerLogoutVariables) =>
      fetchAuthControllerLogout(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerCheckValidTokenHeaders = {
  authorization: string;
};

export type AuthControllerCheckValidTokenError =
  Fetcher.ErrorWrapper<undefined>;

export type AuthControllerCheckValidTokenVariables = {
  headers: AuthControllerCheckValidTokenHeaders;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerCheckValidToken = (
  variables: AuthControllerCheckValidTokenVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    undefined,
    AuthControllerCheckValidTokenError,
    undefined,
    AuthControllerCheckValidTokenHeaders,
    {},
    {}
  >({
    url: "/api/auth/check-valid-token",
    method: "post",
    ...variables,
    signal,
  });

export const useAuthControllerCheckValidToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      AuthControllerCheckValidTokenError,
      AuthControllerCheckValidTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    undefined,
    AuthControllerCheckValidTokenError,
    AuthControllerCheckValidTokenVariables
  >({
    mutationFn: (variables: AuthControllerCheckValidTokenVariables) =>
      fetchAuthControllerCheckValidToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerRevokeDevicePathParams = {
  /**
   * ID của thiết bị cần thu hồi
   */
  id: string;
};

export type AuthControllerRevokeDeviceError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerRevokeDeviceResponse = {
  id?: string;
  name?: string;
  userId?: string;
  /**
   * @format date-time
   */
  lastActive?: string;
  /**
   * @example false
   */
  isActive?: boolean;
  ipAddress?: string | null;
  location?: string | null;
  /**
   * @format date-time
   */
  createdAt?: string;
  /**
   * @format date-time
   */
  updatedAt?: string;
};

export type AuthControllerRevokeDeviceVariables = {
  pathParams: AuthControllerRevokeDevicePathParams;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerRevokeDevice = (
  variables: AuthControllerRevokeDeviceVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    AuthControllerRevokeDeviceResponse,
    AuthControllerRevokeDeviceError,
    undefined,
    {},
    {},
    AuthControllerRevokeDevicePathParams
  >({ url: "/api/auth/devices/{id}", method: "delete", ...variables, signal });

export const useAuthControllerRevokeDevice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerRevokeDeviceResponse,
      AuthControllerRevokeDeviceError,
      AuthControllerRevokeDeviceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    AuthControllerRevokeDeviceResponse,
    AuthControllerRevokeDeviceError,
    AuthControllerRevokeDeviceVariables
  >({
    mutationFn: (variables: AuthControllerRevokeDeviceVariables) =>
      fetchAuthControllerRevokeDevice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthControllerDeleteDevicePathParams = {
  /**
   * ID của thiết bị cần xóa
   */
  id: string;
};

export type AuthControllerDeleteDeviceError = Fetcher.ErrorWrapper<undefined>;

export type AuthControllerDeleteDeviceResponse = {
  id?: string;
  name?: string;
  userId?: string;
  /**
   * @format date-time
   */
  lastActive?: string | null;
  isActive?: boolean;
  ipAddress?: string | null;
  location?: string | null;
  /**
   * @format date-time
   */
  createdAt?: string;
  /**
   * @format date-time
   */
  updatedAt?: string;
};

export type AuthControllerDeleteDeviceVariables = {
  pathParams: AuthControllerDeleteDevicePathParams;
} & ChcnContext["fetcherOptions"];

export const fetchAuthControllerDeleteDevice = (
  variables: AuthControllerDeleteDeviceVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<
    AuthControllerDeleteDeviceResponse,
    AuthControllerDeleteDeviceError,
    undefined,
    {},
    {},
    AuthControllerDeleteDevicePathParams
  >({
    url: "/api/auth/devices/{id}/permanent",
    method: "delete",
    ...variables,
    signal,
  });

export const useAuthControllerDeleteDevice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      AuthControllerDeleteDeviceResponse,
      AuthControllerDeleteDeviceError,
      AuthControllerDeleteDeviceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useChcnContext();
  return reactQuery.useMutation<
    AuthControllerDeleteDeviceResponse,
    AuthControllerDeleteDeviceError,
    AuthControllerDeleteDeviceVariables
  >({
    mutationFn: (variables: AuthControllerDeleteDeviceVariables) =>
      fetchAuthControllerDeleteDevice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UsersControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type UsersControllerFindOneVariables = ChcnContext["fetcherOptions"];

export const fetchUsersControllerFindOne = (
  variables: UsersControllerFindOneVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<undefined, UsersControllerFindOneError, undefined, {}, {}, {}>({
    url: "/api/users/me",
    method: "get",
    ...variables,
    signal,
  });

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function usersControllerFindOneQuery(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/me",
      operationId: "usersControllerFindOne",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUsersControllerFindOne(variables, signal),
  };
}

export const useSuspenseUsersControllerFindOne = <TData = undefined,>(
  variables: UsersControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindOneError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UsersControllerFindOneError,
    TData
  >({
    ...usersControllerFindOneQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUsersControllerFindOne = <TData = undefined,>(
  variables: UsersControllerFindOneVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindOneError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useQuery<undefined, UsersControllerFindOneError, TData>({
    ...usersControllerFindOneQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UsersControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type UsersControllerFindAllVariables = ChcnContext["fetcherOptions"];

export const fetchUsersControllerFindAll = (
  variables: UsersControllerFindAllVariables,
  signal?: AbortSignal,
) =>
  chcnFetch<undefined, UsersControllerFindAllError, undefined, {}, {}, {}>({
    url: "/api/users/all",
    method: "get",
    ...variables,
    signal,
  });

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function usersControllerFindAllQuery(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/all",
      operationId: "usersControllerFindAll",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchUsersControllerFindAll(variables, signal),
  };
}

export const useSuspenseUsersControllerFindAll = <TData = undefined,>(
  variables: UsersControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindAllError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    UsersControllerFindAllError,
    TData
  >({
    ...usersControllerFindAllQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUsersControllerFindAll = <TData = undefined,>(
  variables: UsersControllerFindAllVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UsersControllerFindAllError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useChcnContext(options);
  return reactQuery.useQuery<undefined, UsersControllerFindAllError, TData>({
    ...usersControllerFindAllQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/health";
      operationId: "appControllerHealth";
      variables: AppControllerHealthVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/me";
      operationId: "usersControllerFindOne";
      variables: UsersControllerFindOneVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/all";
      operationId: "usersControllerFindAll";
      variables: UsersControllerFindAllVariables | reactQuery.SkipToken;
    };
